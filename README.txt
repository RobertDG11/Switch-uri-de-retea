Punctajul obtinut pe checkerul local este 105 puncte.

Prezentarea ideii:

Am folosit structurile pentru celula/lista, stiva si coada utilizate la laborator la care am facut cateva modificari(la stive si cozi am pastrat si lungimea pentru a putea sa ma folosesc de ele la creerea acelor macro definitii, EMPTYS si EMPTYQ). De asemenea am mai folosit structura TSwitch in care am retinut informatiile cerute in enunt si am adaugat in plus campul principal de tip int(pentru a retine daca switchul este principal sau secundar; acest lucru ma ajuta la functia set) si vector_stive care creeaza un vector de stive, cum este specificat in enunt. Functiile Push si IntrQ le-am realizat alocand un element de tip TLG, castand informatia din el la tipul TSwitch, dupa care am copiat informatiile camp cu camp si am pus acea celula la locul ei in stiva, respectiv coada. Functiile Pop si ExtrQ le-am realizat eliminand primul element din stiva, respectiv coada si salvand informatia din acesta pe care o returnez ulterior. Am ales implementarea acestor functii cu tipul (void*) deoarece, din cate am citit, acest tip permite returnarea unei valori de orice tip(in cazul de fata aveam nevoie de TSWitch) facand castarea corespunzatoare. Am considerat ca este cea mai corecta alegere tinand cont ca listele sunt generice.
Functia add a fost imparita in add_stiva(adauga in stiva) si add_coada(adauga in coada) deoarece numarul de parametrii difera in functie de modul de functionare al switchului. Functia add_stiva functioneaza pe 3 cazuri(stiva goala, stiva cu un singur element si stiva cu cel putin 2 elemente) explicate in fisierul sursa(functii_Tema2.c). Pe scurt, la cazul general, aceasta scoate toate elementele din stiva si le pune intr-o stiva auxiliara, apoi le pune iar in stiva princiapala, ordonat, comparand la fiecare pas cu elementul care trebuie adaugat. Functia add_coada functioneaza similar cu add_stiva.
Functia del a fost impartita de asemenea in del_stiva si del_coada, din acelasi motiv. Functiile de delete functioneaza similar, punand toate elementele, mai putin cel cu idul "id", intr-o stiva, respectiv coada auxiliara. Dupa ce stiva/coada initala s-a golit, se scot toate elementele din stiva/coada auxiliara si se introduc la loc in cea initiala. Deoarece stivele si cozile sunt deja ordonate, dupa efectuarea acestor operatii, stivele si cozile nu vor trebui reordonate.
Functia set a fost de asemenea impartita in in set_stiva si set_coada, in functie de parametrul "mod_functionare", din aceleasi motive prezentate mai sus. Cele doua functii de set functioneaza asemanator, cautand elementul de id "id". Dupa ce acesta este gasit este eliminat din locul in care a fost gasit si adaugat la noul lui loc, in functie de parametrii functiei, doar in cazul in care nu va fi mutat in exact acelasi loc. Pentru functia set_coada cautarea se face doar in stiva deoarece daca switchul ar fi deja in coada, mutarea nu se va executa(mutare inutila).
Functia show afiseaza continutul cozii si a stivei, folosindu-ma doar de functiile Push/Pop respectiv IntrQ/ExtrQ si de o functie auxiliara de afisare.
Functia ipmin afiseaza valoarea in decimal a primului element din coada(elementul de IP minim) folosindu-se de functia PrimQ(care returneaza informatia din primul element din coada) si de functia convert care face conversia de la IP la un numar in baza 10.

Concluzii: Am realizat cu aceasta tema cat de important este valgrindul pentru debugging si mai ales cat de mult ajuta folosirea flagului --leak-check=full (fara el nu as fi reusit sa scap de memory leak-urile din program).